# Head-First-Design-Pattern
《Head First Design Pattern》 learning notes



### 观察者模式

> 观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新

观察者模式提供了一种对象设计，让主题和观察者之间松耦合。

设计原则：为了交互对象之间的松耦合设计而努力。

![image-20201229142045354](image\Observer-01.png)



有哪些成熟的框架用到了`观察者模式`呢 ？

- 由于游戏开发中会涉及大量的时间响应逻辑，许多游戏引擎的底层使用到了观察者模式，比如Unity3D.
- Spring框架里 ApplicationListener和ApplicationContext这两个接口以及实现类



Java内置的观察者模式弊端：

- java.util.Observable 是一个类，而不是接口，只能去继承，这样就无法去继承其他的类
- setChanged()方法被定义成protected，这样就无法创建Observable实例并组合到自己的对象中



### 装饰者模式

> 动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

- 装饰者和被装饰对象有相同的超类型
- 可以用一个或多个装饰者包装一个对象
- 任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它
- 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的
- 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来修饰对象

![image-20201230181813643](image\Decorator-01.png)

